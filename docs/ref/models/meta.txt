=======================
Model ``_meta`` options
=======================

.. module:: django.db.models.options
   :synopsis: Model meta-class layer

The ``Options API`` is at the core of Django, it enables other parts of the
system such as lookups, queries, forms and the admin to understand the
capabilities of every model. The ``Options API`` is
hidden under the _meta attribute of each model class.

Options can be used for the following:

* Retrieving all field names of a model
* Retrieving all field instances names of a model
* Retrieving a single field by name

Field Types
===========

A model can have 5 types of fields:

Data fields
~~~~~~~~~~~

A data field is any field that has an entry on the database,
for example a CharField, BooleanField, a ForeignKey.

Many-to-many fields
~~~~~~~~~~~~~~~~~~~

A many-to-many field that is defined on the current model.

Related Object
~~~~~~~~~~~~~~

A Related Object is a one-to-many relation from another model
(such as a :class:`django.db.models.ForeignKey`) that points
to the current model.

.. code-block:: python

    class City(models.Model):
        name = models.CharField(max_length=100)

    class Person(models.Model):
        city = models.ForeignKey(City)

In this case, ``City`` has a related object from ``Person``

Related many-to-many objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A Related many-to-many object is a many-to-many relation from another model that points to the current model.

.. code-block:: python

    class City(models.Model):
        name = models.CharField(max_length=100)

    class Person(models.Model):
        cities_lived_in = models.ManyToManyField(City)

In this case, City has a related many-to-many from Person

Virtual fields
~~~~~~~~~~~~~~

Virtual fields are model fields that do not necessarily have a
corresponding database column. they are "model fields" such as
:class:`django.contrib.contenttypes.fields.GenericForeignKey`.

.. code-block:: python

    class Person(models.Model):
        content_type = models.ForeignKey(ContentType, related_name='+')
        object_id_ = models.PositiveIntegerField()
        item = GenericForeignKey('content_type', 'object_id')

:class:`django.contrib.contenttypes.fields.GenericForeignKey` uses ``content_type`` and
``object_id`` to keep track of what model type and id is set to ``item``,
but ``item`` itself does not have a concrete presence on the database.
In this case, ``item`` is a virtual field.

Field Filters
=============

There are several properties that each field can have.

We can use these properties as filters for :meth:`Options.get_fields()`.

Local
~~~~~

A local field is one that's declared directly on a model and not derived from inheritance.
Fields from models that directly inherit from abstract models or proxy classes
are still local.

.. code-block:: python

    class Person(models.Model):
        name = models.CharField(max_length=50)

    class Londoner(Person):
        overdraft = models.DecimalField()

``Londoner`` has two fields (name and overdraft) but only one local field (overdraft).

Hidden
~~~~~~

Hidden fields are only referred to related objects and related many-to-many.
When a relational model (such as :class:`django.db.models.ManyToManyField`,
or :class:`django.db.models.ForeignKey`) specifies a ``related_name`` that
starts with a "+", it tells Django to not create a reverse relation.

.. code-block:: python

    class City(models.Model):
        name = models.CharField(max_length=100)

    class Person(models.Model):
        city = models.ForeignKey(City, related_name='+')

``City`` has a related hidden object from ``Person`` (as you can't access person_set)

Concrete
~~~~~~~~

Concrete fields are fields that have a column

Proxied relations
~~~~~~~~~~~~~~~~~

Proxied relations are relations that point to a proxy of a model.

.. code-block:: python

    class Person(models.Model):
        pass

    class ProxyPerson(Person):
        class Meta:
            proxy = True

    class RelationToProxy(models.Model):
         proxy_person = models.ForeignKey(ProxyPerson)

In this case, ``Person`` has no related objects, but it has 1 proxied related
object from ``RelationToProxy``.

``Options API``
===============

Retrieve a field instance by name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. method:: Options.get_field(field_name, m2m=True, data=True, related_m2m=False, related_objects=False, virtual=False)

    Returns the field instance given a name of a field.

    ``field_name`` can be the name of a field on a model or it can also be a reverse relation
    name (related query name).

    ``field_name`` is the only **required** field. All the other arguments
    are flags that are used internally to optimize the lookup. By default, :meth:`Options.get_field()`
    will only look up data and many-to-many fields, but all field types can be activated.
    Hidden and proxied relations are not available. If a field with the given name is not found
    it will raise a `FieldDoesNotExist`` error.

    .. code-block:: python

        >>> from django.contrib.auth.models import User

        >>> User._meta.get_field('username')# A data field
        <django.db.models.fields.CharField: username>

        >>> User._meta.get_field('logentry', related_objects=True) # A related object
        <RelatedObject: admin:logentry related to user>

        >>> LogEntry._meta.get_field('user') # ForeignKey can be queried by field name
        <django.db.models.fields.related.ForeignKey: user>
        >>> LogEntry._meta.get_field('user_id') # .. and also by database column name
        <django.db.models.fields.related.ForeignKey: user>

        >>> User._meta.get_field('does_not_exist') # A non existent field
        Traceback (most recent call last):
            ...
        FieldDoesNotExist: User has no field named 'does_not_exist'

    .. note::
        The default arguments of :meth:`Options.get_field()` might not be what you expect.
        :meth:`Options.get_fields()` only enables data fields, while :meth:`Options.get_field()`
        enables data and m2m. This is because of backwards-compatibility
        issues (read more below).

Retrieve all field names
~~~~~~~~~~~~~~~~~~~~~~~~

.. attribute:: Options.field_names

    Returns a list of all field names (including reverse relations) on the
    current model.

    .. code-block:: python

        >>> User._meta.field_names
        ['username', 'first_name', 'last_name', 'logentry',
         'is_active', 'email', 'is_superuser', 'is_staff',
         'last_login', 'groups', 'user_permissions', 'password',
         'id', 'date_joined']

Retrieve field instances
~~~~~~~~~~~~~~~~~~~~~~~~

.. method:: Options.get_fields(m2m=False, data=True, related_m2m=False, related_objects=False, virtual=False, include_parents=True, include_non_concrete=True, include_hidden=False, include_proxy=False)

    Returns a list of fields given a list of field types and filters.

    get_fields takes a set of flags as parameters and returns a tuple
    of field instances. The flags are a combination of field types
    and field filters. All possible combinations of filters and fields
    are possible, although some will have no effect (such as
    include_proxy combined with data or m2m by itself).

    .. code-block:: python

        >>> User._meta.get_fields() # Only data by default
        (<django.db.models.fields.AutoField: id>,
         <django.db.models.fields.CharField: password>,
         <django.db.models.fields.DateTimeField: last_login>,
         <django.db.models.fields.BooleanField: is_superuser>,
         <django.db.models.fields.CharField: username>,
         <django.db.models.fields.CharField: first_name>,
         <django.db.models.fields.CharField: last_name>,
         <django.db.models.fields.EmailField: email>,
         <django.db.models.fields.BooleanField: is_staff>,
         <django.db.models.fields.BooleanField: is_active>,
         <django.db.models.fields.DateTimeField: date_joined>)

        >>> User._meta.get_fields(data=False, related_objects=True) # only related_objects
        (<RelatedObject: admin:logentry related to user>,)

        >>> User._meta.get_fields(data=False, related_objects=True, include_hidden=True) # only related_objects including hidden
        (<RelatedObject: auth:user_groups related to user>,
         <RelatedObject: auth:user_user_permissions related to user>,
         <RelatedObject: admin:logentry related to user>)

``Fast-Access API``
===================

In order to provide a simple and usable API for developers to use,
Django provides some Fast-access endpoints that are used
by Django internally. The reason these APIs exist is to ensure
field access is always fast. This API is composed of a specific set
of properties that are cached on first access, and are guaranteed to
be fast. If you have the choice between using a fast-access API
or using one of the official APIs, it is recommended to use the
fast-access API for performance reasons

.. attribute:: Options.fields

    Returns a list of all data fields.

.. attribute:: Options.concrete_fields

    Returns a list of all concrete data fields.

.. attribute:: Options.local_concrete_fields

    Returns a list of all concrete data fields that
    have not been inherited from another model.

.. attribute:: Options.many_to_many

    Returns a list of all many-to-many fields.
